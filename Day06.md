#   Day06

## java中线程运行的模式-抢占式

* 分时式：平均分配CPU使用权

* 抢占式：哪个线程抢到CpU就执行哪个线程的代码

## 实现Runnable接口的好处

* 解决java类单继承的局限性
* 可以更好的在多个线程之间共享数据（卖票案例）
* 为线程池提供前提条件（下一次上课的内容）



## 实现Runnable接口的类能否直接借用getName（）方法

* 不能，因为该类没有继承Thread类，可以使用Thread.currentThread().getName()



## 线程安全的概念

* 多个线程同时操作一个共享资源时仍然能得到正确的结果则称为线程安全，反之则不安全。



## 如何实现线程安全

1. 同步代码块
2. 同步方法
3. Lock接口-（Lock时JDK1.5新特性，如果资源竞争不激烈（线程数量多），使用Lock接口）

* #### ==同步代码块==

```java
/*
  同步代码块的格式
  synchronized(锁对象){
  //操作共享资源代码
  }
   
```

* ==锁对象注意事项==:任意类型的对象都可以充当锁对象、该锁对象必须被所有线程共享（所有线程共用一个对象)


* #### ==Lock接口==

```java
Lock 接口常用方法
	void lock()； 获得锁头
	void unlock(); 释放锁
Lock 接口的实现类：ReentrantLock 互斥锁：
	private Lock lockObj = new ReentrantLock();

```

* 释放锁最好放在finally里面
![1561382910933](D:\JAVA学习资料\.vscode\就业班笔记\图片\1561382910933.png)

## 同步方法的锁对象

* 静态同步方法： 类名.class
* 非静态同步方法: this